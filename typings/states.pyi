import numpy as np
from src.pycfd_types import Array as Array, IDir as IDir, real_t as real_t
from src.varindexes import IBX as IBX, IBY as IBY, IBZ as IBZ, IE as IE, IP as IP, IPSI as IPSI, IR as IR, IU as IU, IV as IV, IW as IW

class State(np.ndarray):
    def __new__(cls, data: Array | None = None) -> State: ...
    def __array_finalize__(self, obj: Array | None) -> None: ...
    def __add__(self, other) -> State: ...
    def __sub__(self, other) -> State: ...
    def __mul__(self, other) -> State: ...
    def __truediv__(self, other): ...
    def __floordiv__(self, other): ...
    def __pow__(self, other): ...
    def __radd__(self, other): ...
    def __rsub__(self, other): ...
    def __rmul__(self, other): ...
    def __rtruediv__(self, other): ...
    def __rfloordiv__(self, other): ...
    def __rpow__(self, other): ...
    def __iadd__(self, other): ...
    def __isub__(self, other): ...
    def __imul__(self, other): ...
    def __itruediv__(self, other): ...
    def __ifloordiv__(self, other): ...
    def __ipow__(self, other): ...
    def __neg__(self): ...
    def __pos__(self): ...
    def __abs__(self): ...
    def __eq__(self, other): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __ne__(self, other): ...

def get_state_from_array(Q: Array, i: int, j: int) -> State: ...
def set_state_into_array(Q: Array, i: int, j: int, s: State) -> None: ...
def cell_primToCons(q: State) -> State: ...
def cell_consToPrim(u: State) -> State: ...
def grid_consToPrim(U: Array, Q: Array) -> None: ...
def grid_primToCons(Q: Array, U: Array) -> None: ...
def primToCons(*args: tuple[Array]|tuple[State]) -> None | State: ...
def consToPrim(*args: tuple[Array]|tuple[State]) -> None | State: ...
def swap_components(s: State, idir: IDir) -> State: ...
